<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Johan Hidding" />
  <title>ParaNoodles</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Dosis" rel="stylesheet">
</head>
<body>
<header id="title-block-header">
<h1 class="title">ParaNoodles</h1>
<p class="author">Johan Hidding</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#building-paranoodles">Building ParaNoodles</a></li>
<li><a href="#module">Module</a></li>
<li><a href="#problem-statement">Problem statement</a><ul>
<li><a href="#example-damped-harmonic-oscillator">Example: damped harmonic oscillator</a></li>
</ul></li>
<li><a href="#parareal">Parareal</a><ul>
<li><a href="#noodlify">Noodlify</a></li>
</ul></li>
<li><a href="#tests">Tests</a></li>
</ul>
</nav>
<p>ParaNoodles is an implementation of the Parareal on top of the Noodles framework in Python. <strong>Parareal</strong> is an algorithm for Parallel-in-time integration of ODEs (or PDEs through method of lines). <strong>Noodles</strong> is a framework for parallel programming in Python.</p>
<h2 id="building-paranoodles">Building ParaNoodles</h2>
<p>ParaNoodles is 100% Python.</p>
<pre><code>pip install .</code></pre>
<p>To run on a cluster environment (with the Xenon runner) you need <code>pyxenon</code> installed and a decently recent Java Runtime present.</p>
<pre><code>pip install pyxenon</code></pre>
<h2 id="module">Module</h2>
<div class="noweb">
<p>file: «paranoodles/__init__.py»=</p>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># empty for now</span></span></code></pre></div>
<h2 id="problem-statement">Problem statement</h2>
<p>I tried to implement the problem statement using abstract base classes (<code>ABC</code> module) and the <code>typing</code> module. However, type annotation in Python is still an immature feature (to say the least, it’s next to useless). The little annotation remaining should be considered documentation.</p>
<div class="noweb">
<p>file: «paranoodles/abstract.py»=</p>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">from</span> __future__ <span class="im">import</span> annotations  <span class="co"># enable self-reference in type annotations</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="im">from</span> typing <span class="im">import</span> Callable</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="im">from</span> abc <span class="im">import</span> (ABC, abstractmethod)</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="op">&lt;&lt;</span>abstract<span class="op">-</span>types<span class="op">&gt;&gt;</span></span></code></pre></div>
<p>We have an ODE in the form</p>
<p><span id="eq:ode" style="display: inline-block; position: relative; width: 100%"><span class="math display">\[y&#39; = f(y, t).\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(1)</span></span></p>
<p>Here <span class="math inline">\(y\)</span> can be a scalar value, a vector of values (say a <code>numpy</code> array), or any expression of <em>state</em>. A naive implementation of an ODE integrator would be</p>
<p><span id="eq:euler-method" style="display: inline-block; position: relative; width: 100%"><span class="math display">\[y_{n+1} = y_{n} + \Delta t f(y_{n}, t).\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(2)</span></span></p>
<p>eq. <a href="#eq:euler-method">2</a> is known as the <em>forward Euler method</em>. We can capture the <em>state</em> <span class="math inline">\(y\)</span> in an abstract class <code>Vector</code></p>
<div class="noweb">
<p>«abstract-types»=</p>
</div>
<div class="sourceCode" id="abstract-types"><pre class="sourceCode python"><code class="sourceCode python"><span id="abstract-types-1"><a href="#abstract-types-1"></a><span class="kw">class</span> Vector(ABC):</span>
<span id="abstract-types-2"><a href="#abstract-types-2"></a>    <span class="co">&quot;&quot;&quot;Abstract base class for state variable of a problem.</span></span>
<span id="abstract-types-3"><a href="#abstract-types-3"></a><span class="co">    This should support simple arithmatic operations.&quot;&quot;&quot;</span></span>
<span id="abstract-types-4"><a href="#abstract-types-4"></a>    <span class="at">@abstractmethod</span></span>
<span id="abstract-types-5"><a href="#abstract-types-5"></a>    <span class="kw">def</span> <span class="fu">__add__</span>(<span class="va">self</span>, other: Vector) <span class="op">-&gt;</span> Vector:</span>
<span id="abstract-types-6"><a href="#abstract-types-6"></a>        <span class="co">&quot;&quot;&quot;Summation of two result vectors.&quot;&quot;&quot;</span></span>
<span id="abstract-types-7"><a href="#abstract-types-7"></a>        <span class="cf">pass</span></span>
<span id="abstract-types-8"><a href="#abstract-types-8"></a></span>
<span id="abstract-types-9"><a href="#abstract-types-9"></a>    <span class="at">@abstractmethod</span></span>
<span id="abstract-types-10"><a href="#abstract-types-10"></a>    <span class="kw">def</span> <span class="fu">__sub__</span>(<span class="va">self</span>, other: Vector) <span class="op">-&gt;</span> Vector:</span>
<span id="abstract-types-11"><a href="#abstract-types-11"></a>        <span class="co">&quot;&quot;&quot;Difference between two result vectors.&quot;&quot;&quot;</span></span>
<span id="abstract-types-12"><a href="#abstract-types-12"></a>        <span class="cf">pass</span></span>
<span id="abstract-types-13"><a href="#abstract-types-13"></a></span>
<span id="abstract-types-14"><a href="#abstract-types-14"></a>    <span class="at">@abstractmethod</span></span>
<span id="abstract-types-15"><a href="#abstract-types-15"></a>    <span class="kw">def</span> <span class="fu">__mul__</span>(<span class="va">self</span>, other: <span class="bu">float</span>) <span class="op">-&gt;</span> Vector:</span>
<span id="abstract-types-16"><a href="#abstract-types-16"></a>        <span class="co">&quot;&quot;&quot;Scale vector with scalar.&quot;&quot;&quot;</span></span>
<span id="abstract-types-17"><a href="#abstract-types-17"></a>        <span class="cf">pass</span></span>
<span id="abstract-types-18"><a href="#abstract-types-18"></a></span>
<span id="abstract-types-19"><a href="#abstract-types-19"></a>    <span class="kw">def</span> <span class="fu">__rmul__</span>(<span class="va">self</span>, other: <span class="bu">float</span>) <span class="op">-&gt;</span> Vector:</span>
<span id="abstract-types-20"><a href="#abstract-types-20"></a>        <span class="cf">return</span> <span class="va">self</span> <span class="op">*</span> other</span></code></pre></div>
<p>Note that we don’t make a distinction here between a state vector and a vector representing a change in state. This may change in the future.</p>
<p>An ODE is then given as a function taking a <code>Vector</code> and a <code>float</code> returning a <code>Vector</code>. We define the type <code>Problem</code>:</p>
<div class="noweb">
<p>«abstract-types»=+</p>
</div>
<div class="sourceCode" id="abstract-types"><pre class="sourceCode python"><code class="sourceCode python"><span id="abstract-types-1"><a href="#abstract-types-1"></a>Problem <span class="op">=</span> Callable[[Vector, <span class="bu">float</span>], Vector]</span></code></pre></div>
<p>If we have a <code>Problem</code>, we’re after a <code>Solution</code>: a function that, given an initial <code>Vector</code>, initial time and final time, gives the resulting <code>Vector</code>.</p>
<div class="noweb">
<p>«abstract-types»=+</p>
</div>
<div class="sourceCode" id="abstract-types"><pre class="sourceCode python"><code class="sourceCode python"><span id="abstract-types-1"><a href="#abstract-types-1"></a>Solution <span class="op">=</span> Callable[[Vector, <span class="bu">float</span>, <span class="bu">float</span>], Vector]</span></code></pre></div>
<p>Then the forward Euler method (eq. <a href="#eq:euler-method">2</a>), is given by</p>
<div class="noweb">
<p>file: «paranoodles/forward_euler.py»=</p>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Vector, Problem, Solution)</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">def</span> forward_euler(f: Problem) <span class="op">-&gt;</span> Solution:</span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="kw">def</span> step(y: Vector, t_0: <span class="bu">float</span>, t_1: <span class="bu">float</span>) <span class="op">-&gt;</span> Vector:</span>
<span id="cb5-5"><a href="#cb5-5"></a>        <span class="co">&quot;&quot;&quot;Stepping function of Euler method.&quot;&quot;&quot;</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>        <span class="cf">return</span> y <span class="op">+</span> (t_1 <span class="op">-</span> t_0) <span class="op">*</span> f(y, t_0)</span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="cf">return</span> step</span></code></pre></div>
<p>Any existing solution can be iterated over to provide a solution over a larger time interval. The <code>iterate_solution</code> function runs a given solution with a step-size fixed to <span class="math inline">\(\Delta t = h\)</span>.</p>
<!--$${\rm Iter}[S, h]\Big|_{t_0, y = y}^{t_1} = \begin{cases}-->
<!--y & t_0 = t_1 \\-->
<!--{\rm Iter}[S, h]\big|_{t_0 + h, y = S(y, t_0, t_0 + h)}^{t_1} & {\rm otherwise}-->
<!--\end{cases}.$$-->
<div class="noweb">
<p>file: «paranoodles/iterate_solution.py»=</p>
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Vector, Problem, Solution)</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="kw">def</span> iterate_solution(step: Solution, h: <span class="bu">float</span>) <span class="op">-&gt;</span> Solution:</span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="kw">def</span> iter_step(y: Vector, t_0: <span class="bu">float</span>, t_1: <span class="bu">float</span>) <span class="op">-&gt;</span> Vector:</span>
<span id="cb6-6"><a href="#cb6-6"></a>        <span class="co">&quot;&quot;&quot;Stepping function of iterated solution.&quot;&quot;&quot;</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>        n <span class="op">=</span> math.ceil((t_1 <span class="op">-</span> t_0) <span class="op">/</span> h)</span>
<span id="cb6-8"><a href="#cb6-8"></a>        steps <span class="op">=</span> np.arange(t_0, t_1, n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb6-9"><a href="#cb6-9"></a>        <span class="cf">for</span> t_a, t_b <span class="kw">in</span> <span class="bu">zip</span>(steps[:<span class="op">-</span><span class="dv">1</span>], steps[<span class="dv">1</span>:])</span>
<span id="cb6-10"><a href="#cb6-10"></a>            y <span class="op">=</span> step(y, t_a, t_b)</span>
<span id="cb6-11"><a href="#cb6-11"></a>        <span class="cf">return</span> y         </span>
<span id="cb6-12"><a href="#cb6-12"></a>    <span class="cf">return</span> iter_step</span></code></pre></div>
<h3 id="example-damped-harmonic-oscillator">Example: damped harmonic oscillator</h3>
<p>The harmonic oscillator can model the movement of a pendulum or the vibration of a mass on a string.</p>
<p><span class="math display">\[y&#39;&#39; + 2\zeta \omega_0 y&#39; + \omega_0^2 y = 0,\]</span></p>
<p>where <span class="math inline">\(\omega_0 = \sqrt{k/m}\)</span> and <span class="math inline">\(\zeta = c / 2\sqrt{mk}\)</span>, <span class="math inline">\(k\)</span> being the spring constant, <span class="math inline">\(m\)</span> the test mass and <span class="math inline">\(c\)</span> the friction constant.</p>
<p>To solve this second order ODE we need to introduce a second variable to solve for. Say <span class="math inline">\(q = y\)</span> and <span class="math inline">\(p = y&#39;\)</span>.</p>
<p><span id="eq:harmonic-oscillator" style="display: inline-block; position: relative; width: 100%"><span class="math display">\[\begin{aligned}
    q&#39; &amp;= p\\
    p&#39; &amp;= -2\zeta \omega_0 p + \omega_0^2 q
\end{aligned}\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(3)</span></span> </p>
<p>The <code>Problem</code> is then given as</p>
<div class="noweb">
<p>file: «paranoodles/harmonic_oscillator.py»=</p>
</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Problem)</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="kw">def</span> harmonic_oscillator(omega_0: <span class="bu">float</span>, zeta: <span class="bu">float</span>) <span class="op">-&gt;</span> Problem:</span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="kw">def</span> f(y, t):</span>
<span id="cb7-6"><a href="#cb7-6"></a>        <span class="cf">return</span> np.r_[y[<span class="dv">1</span>], <span class="dv">-2</span> <span class="op">*</span> zeta <span class="op">*</span> omega_0 <span class="op">*</span> y[<span class="dv">1</span>] <span class="op">-</span> omega_0<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> y[<span class="dv">0</span>]]</span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="cf">return</span> f</span>
<span id="cb7-8"><a href="#cb7-8"></a>    </span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="op">&lt;&lt;</span>harmonic<span class="op">-</span>oscillator<span class="op">-</span>solution<span class="op">&gt;&gt;</span></span></code></pre></div>
<h4 id="exact-solution">Exact solution</h4>
<p>The damped harmonic oscillator has an exact solution, given the ansatz <span class="math inline">\(y = A \exp(z t)\)</span>, we get</p>
<p><span class="math display">\[z = \omega_0\left(-\zeta \pm \sqrt{\zeta^2 - 1}\right).\]</span></p>
<p>There are three cases: <em>overdamped</em> (<span class="math inline">\(\zeta &gt; 1\)</span>), <em>critical dampening</em> <span class="math inline">\(\zeta = 1,\ z = -\omega_0\)</span>, and <em>underdamped</em> <span class="math inline">\(0 \le \zeta &lt; 1,\ z = \omega_0 \exp (i\xi)\)</span>.</p>
<p>In the underdamped case,</p>
<p><span class="math display">\[y = A\quad \underbrace{\exp(-\omega_0\zeta t)}_{\rm dampening}\quad\underbrace{\exp(\pm i \omega_0 \sqrt{1 - \zeta^2} t)}_{\rm oscillation},\]</span></p>
<p>Given an initial condition <span class="math inline">\(q_0 = 1, p_0 = 0\)</span>, the solution is computed as</p>
<div class="noweb">
<p>«harmonic-oscillator-solution»=</p>
</div>
<div class="sourceCode" id="harmonic-oscillator-solution"><pre class="sourceCode python"><code class="sourceCode python"><span id="harmonic-oscillator-solution-1"><a href="#harmonic-oscillator-solution-1"></a><span class="kw">def</span> underdamped_solution(omega_0: <span class="bu">float</span>, zeta: <span class="bu">float</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="harmonic-oscillator-solution-2"><a href="#harmonic-oscillator-solution-2"></a>    amp   <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> zeta<span class="op">**</span><span class="dv">2</span>)</span>
<span id="harmonic-oscillator-solution-3"><a href="#harmonic-oscillator-solution-3"></a>    phase <span class="op">=</span> np.arcsin(zeta)</span>
<span id="harmonic-oscillator-solution-4"><a href="#harmonic-oscillator-solution-4"></a>    freq  <span class="op">=</span> omega_0 <span class="op">*</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> zeta<span class="op">**</span><span class="dv">2</span>)</span>
<span id="harmonic-oscillator-solution-5"><a href="#harmonic-oscillator-solution-5"></a></span>
<span id="harmonic-oscillator-solution-6"><a href="#harmonic-oscillator-solution-6"></a>    <span class="kw">def</span> f(t):</span>
<span id="harmonic-oscillator-solution-7"><a href="#harmonic-oscillator-solution-7"></a>        dampening <span class="op">=</span> np.exp(<span class="op">-</span>omega_0<span class="op">*</span>zeta<span class="op">*</span>t)</span>
<span id="harmonic-oscillator-solution-8"><a href="#harmonic-oscillator-solution-8"></a>        q <span class="op">=</span> amp <span class="op">*</span> dampening <span class="op">*</span> np.cos(freq <span class="op">*</span> t <span class="op">-</span> phase)</span>
<span id="harmonic-oscillator-solution-9"><a href="#harmonic-oscillator-solution-9"></a>        p <span class="op">=</span> <span class="op">-</span> amp <span class="op">*</span> omega_0 <span class="op">*</span> dampening <span class="op">*</span> np.sin(freq <span class="op">*</span> t)</span>
<span id="harmonic-oscillator-solution-10"><a href="#harmonic-oscillator-solution-10"></a>        <span class="cf">return</span> np.c_[q, p]</span>
<span id="harmonic-oscillator-solution-11"><a href="#harmonic-oscillator-solution-11"></a>    <span class="cf">return</span> f</span></code></pre></div>
<h4 id="numeric-solution">Numeric solution</h4>
<p>To plot a <code>Solution</code>, we need to tabulate the results for a given sequence of time points.</p>
<div class="noweb">
<p>file: «paranoodles/tabulate_solution.py»=</p>
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Solution, Vector)</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="im">from</span> typing <span class="im">import</span> (Sequence)</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a>Array <span class="op">=</span> np.ndarray</span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="kw">def</span> tabulate(step: Solution, y_0: Vector, t: Array) <span class="op">-&gt;</span> Sequence[Vector]:</span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="co">&quot;&quot;&quot;Tabulate the step-wise solution, starting from `y_0`, for every time</span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="co">    point given in array `t`.&quot;&quot;&quot;</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(y_0, Array):</span>
<span id="cb8-11"><a href="#cb8-11"></a>        <span class="cf">return</span> tabulate_np(step, y_0, t)</span>
<span id="cb8-12"><a href="#cb8-12"></a>        </span>
<span id="cb8-13"><a href="#cb8-13"></a>    y <span class="op">=</span> [y_0]</span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, t.size):</span>
<span id="cb8-15"><a href="#cb8-15"></a>        y_i <span class="op">=</span> step(y[i<span class="dv">-1</span>], t[i<span class="dv">-1</span>], t[i])</span>
<span id="cb8-16"><a href="#cb8-16"></a>        y.append(y_i)</span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span class="cf">return</span> y</span>
<span id="cb8-18"><a href="#cb8-18"></a></span>
<span id="cb8-19"><a href="#cb8-19"></a><span class="op">&lt;&lt;</span>tabulate<span class="op">-</span>np<span class="op">&gt;&gt;</span></span></code></pre></div>
<p>In the case that the <code>Vector</code> type is actually a numpy array, we can specialize the <code>tabulate</code> routine to return a larger array.</p>
<div class="noweb">
<p>«tabulate-np»=</p>
</div>
<div class="sourceCode" id="tabulate-np"><pre class="sourceCode python"><code class="sourceCode python"><span id="tabulate-np-1"><a href="#tabulate-np-1"></a><span class="kw">def</span> tabulate_np(step: Solution, y_0: Array, t: Array) <span class="op">-&gt;</span> Array:</span>
<span id="tabulate-np-2"><a href="#tabulate-np-2"></a>    y <span class="op">=</span> np.zeros(dtype<span class="op">=</span>y_0.dtype, shape<span class="op">=</span>(t.size,) <span class="op">+</span> y_0.shape)</span>
<span id="tabulate-np-3"><a href="#tabulate-np-3"></a>    y[<span class="dv">0</span>] <span class="op">=</span> y_0</span>
<span id="tabulate-np-4"><a href="#tabulate-np-4"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, t.size):</span>
<span id="tabulate-np-5"><a href="#tabulate-np-5"></a>        y[i] <span class="op">=</span> step(y[i<span class="dv">-1</span>], t[i<span class="dv">-1</span>], t[i])</span>
<span id="tabulate-np-6"><a href="#tabulate-np-6"></a>    <span class="cf">return</span> y</span></code></pre></div>
<h4 id="plotting-the-harmonic-oscillator">Plotting the harmonic oscillator</h4>
<div class="noweb">
<p>«plot-harmonic-oscillator»=</p>
</div>
<div class="sourceCode" id="plot-harmonic-oscillator"><pre class="sourceCode python"><code class="sourceCode python"><span id="plot-harmonic-oscillator-1"><a href="#plot-harmonic-oscillator-1"></a><span class="im">import</span> matplotlib.pylab <span class="im">as</span> plt</span>
<span id="plot-harmonic-oscillator-2"><a href="#plot-harmonic-oscillator-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="plot-harmonic-oscillator-3"><a href="#plot-harmonic-oscillator-3"></a></span>
<span id="plot-harmonic-oscillator-4"><a href="#plot-harmonic-oscillator-4"></a><span class="im">from</span> paranoodles.harmonic_oscillator <span class="im">import</span> <span class="op">\</span></span>
<span id="plot-harmonic-oscillator-5"><a href="#plot-harmonic-oscillator-5"></a>    ( harmonic_oscillator, underdamped_solution )</span>
<span id="plot-harmonic-oscillator-6"><a href="#plot-harmonic-oscillator-6"></a><span class="im">from</span> paranoodles.forward_euler <span class="im">import</span> <span class="op">\</span></span>
<span id="plot-harmonic-oscillator-7"><a href="#plot-harmonic-oscillator-7"></a>    ( forward_euler )</span>
<span id="plot-harmonic-oscillator-8"><a href="#plot-harmonic-oscillator-8"></a><span class="im">from</span> paranoodles.tabulate_solution <span class="im">import</span> <span class="op">\</span></span>
<span id="plot-harmonic-oscillator-9"><a href="#plot-harmonic-oscillator-9"></a>    ( tabulate )</span>
<span id="plot-harmonic-oscillator-10"><a href="#plot-harmonic-oscillator-10"></a></span>
<span id="plot-harmonic-oscillator-11"><a href="#plot-harmonic-oscillator-11"></a>omega_0 <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="plot-harmonic-oscillator-12"><a href="#plot-harmonic-oscillator-12"></a>zeta <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="plot-harmonic-oscillator-13"><a href="#plot-harmonic-oscillator-13"></a>f <span class="op">=</span> harmonic_oscillator(omega_0, zeta)</span>
<span id="plot-harmonic-oscillator-14"><a href="#plot-harmonic-oscillator-14"></a>t <span class="op">=</span> np.linspace(<span class="fl">0.0</span>, <span class="fl">15.0</span>, <span class="dv">100</span>)</span>
<span id="plot-harmonic-oscillator-15"><a href="#plot-harmonic-oscillator-15"></a>y_euler <span class="op">=</span> tabulate(forward_euler(f), np.r_[<span class="fl">1.0</span>, <span class="fl">0.0</span>], t)</span>
<span id="plot-harmonic-oscillator-16"><a href="#plot-harmonic-oscillator-16"></a>y_exact <span class="op">=</span> underdamped_solution(omega_0, zeta)(t)</span>
<span id="plot-harmonic-oscillator-17"><a href="#plot-harmonic-oscillator-17"></a></span>
<span id="plot-harmonic-oscillator-18"><a href="#plot-harmonic-oscillator-18"></a>plt.plot(t, y_euler[:,<span class="dv">0</span>], color<span class="op">=</span><span class="st">&#39;slateblue&#39;</span>, label<span class="op">=</span><span class="st">&quot;euler&quot;</span>)</span>
<span id="plot-harmonic-oscillator-19"><a href="#plot-harmonic-oscillator-19"></a>plt.plot(t, y_exact[:,<span class="dv">0</span>], color<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&quot;exact&quot;</span>)</span>
<span id="plot-harmonic-oscillator-20"><a href="#plot-harmonic-oscillator-20"></a>plt.plot(t, y_euler[:,<span class="dv">1</span>], color<span class="op">=</span><span class="st">&#39;slateblue&#39;</span>, linestyle<span class="op">=</span><span class="st">&#39;:&#39;</span>)</span>
<span id="plot-harmonic-oscillator-21"><a href="#plot-harmonic-oscillator-21"></a>plt.plot(t, y_exact[:,<span class="dv">1</span>], color<span class="op">=</span><span class="st">&#39;k&#39;</span>, linestyle<span class="op">=</span><span class="st">&#39;:&#39;</span>)</span>
<span id="plot-harmonic-oscillator-22"><a href="#plot-harmonic-oscillator-22"></a>plt.legend()</span>
<span id="plot-harmonic-oscillator-23"><a href="#plot-harmonic-oscillator-23"></a>plt.savefig(<span class="st">&quot;harmonic.svg&quot;</span>)</span></code></pre></div>
<figure>
<img src="./harmonic.svg" alt="" /><figcaption>Damped harmonic oscillator</figcaption>
</figure>
<h2 id="parareal">Parareal</h2>
<p>From Wikipedia:</p>
<blockquote>
<p>Parareal solves an initial value problem of the form</p>
<p><span class="math display">\[\dot{y}(t) = f(y(t), t), \quad y(t_0) = y_0 \quad \text{with} \quad t_0 \leq t \leq T.\]</span></p>
<p>Here, the right hand side <span class="math inline">\(f\)</span> can correspond to the spatial discretization of a partial differential equation in a method of lines approach. Parareal now requires a decomposition of the time interval <span class="math inline">\([t_0, T]\)</span> into <span class="math inline">\(P\)</span> so-called time slices <span class="math inline">\([t_j, t_{j+1}]\)</span> such that</p>
<p><span class="math display">\[[t_0, T] = [t_0, t_1] \cup [t_1, t_2] \cup \ldots \cup [t_{P-1}, t_{P} ].\]</span></p>
<p>Each time slice is assigned to one processing unit when parallelizing the algorithm, so that <span class="math inline">\(P\)</span> is equal to the number of processing units used for Parareal.</p>
<p>Parareal is based on the iterative application of two methods for integration of ordinary differential equations. One, commonly labelled <span class="math inline">\({\mathcal {F}}\)</span>, should be of high accuracy and computational cost while the other, typically labelled <span class="math inline">\({\mathcal {G}}\)</span>, must be computationally cheap but can be much less accurate. Typically, some form of Runge-Kutta method is chosen for both coarse and fine integrator, where <span class="math inline">\({\mathcal {G}}\)</span> might be of lower order and use a larger time step than <span class="math inline">\({\mathcal {F}}\)</span>. If the initial value problem stems from the discretization of a PDE, <span class="math inline">\({\mathcal {G}}\)</span> can also use a coarser spatial discretization, but this can negatively impact convergence unless high order interpolation is used. The result of numerical integration with one of these methods over a time slice <span class="math inline">\([t_{j}, t_{j+1}]\)</span> for some starting value <span class="math inline">\(y_{j}\)</span> given at <span class="math inline">\(t_{j}\)</span> is then written as</p>
<p><span class="math display">\[y = \mathcal{F}(y_j, t_j, t_{j+1})\ {\rm or}\ y = \mathcal{G}(y_j, t_j, t_{j+1}).\]</span></p>
<p>Serial time integration with the fine method would then correspond to a step-by-step computation of</p>
<p><span class="math display">\[y_{j+1} = \mathcal{F}(y_j, t_j, t_{j+1}), \quad j=0, \ldots, P-1.\]</span></p>
<p>Parareal instead uses the following iteration</p>
<p><span class="math display">\[y_{j+1}^{k+1} = \mathcal{G}(y^{k+1}_j, t_j, t_{j+1}) + \mathcal{F}(y^k_j, t_j, t_{j+1}) - \mathcal{G}(y^k_j, t_j, t_{j+1}),\\ \quad j=0, \ldots, P-1, \quad k=0, \ldots, K-1,\]</span></p>
<p>where <span class="math inline">\(k\)</span> is the iteration counter. As the iteration converges and <span class="math inline">\(y^{k+1}_j - y^k_j \to 0\)</span>, the terms from the coarse method cancel out and Parareal reproduces the solution that is obtained by the serial execution of the fine method only. It can be shown that Parareal converges after a maximum of <span class="math inline">\(P\)</span> iterations. For Parareal to provide speedup, however, it has to converge in a number of iterations significantly smaller than the number of time slices, that is <span class="math inline">\(K \ll P\)</span>.</p>
<p>In the Parareal iteration, the computationally expensive evaluation of <span class="math inline">\(\mathcal{F}(y^k_j, t_j, t_{j+1})\)</span> can be performed in parallel on <span class="math inline">\(P\)</span> processing units. By contrast, the dependency of <span class="math inline">\(y^{k+1}_{j+1}\)</span> on <span class="math inline">\(\mathcal{G}(y^{k+1}_j, t_j, t_{j+1})\)</span> means that the coarse correction has to be computed in serial order.</p>
</blockquote>
<p>The core equation translates to:</p>
<div class="noweb">
<p>«parareal-core»=</p>
</div>
<div class="sourceCode" id="parareal-core"><pre class="sourceCode python"><code class="sourceCode python"><span id="parareal-core-1"><a href="#parareal-core-1"></a>y_n[i] <span class="op">=</span> coarse(y_n[i<span class="dv">-1</span>], t[i<span class="dv">-1</span>], t[i]) <span class="op">\</span></span>
<span id="parareal-core-2"><a href="#parareal-core-2"></a>       <span class="op">+</span> fine(y[i<span class="dv">-1</span>], t[i<span class="dv">-1</span>], t[i]) <span class="op">\</span></span>
<span id="parareal-core-3"><a href="#parareal-core-3"></a>       <span class="op">-</span> coarse(y[i<span class="dv">-1</span>], t[i<span class="dv">-1</span>], t[i])</span></code></pre></div>
<p>The rest is boiler plate.</p>
<div class="noweb">
<p>file: «paranoodles/parareal.py»=</p>
</div>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Solution)</span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">def</span> parareal(coarse: Solution, fine: Solution):</span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="kw">def</span> f(y, t):</span>
<span id="cb9-5"><a href="#cb9-5"></a>        m <span class="op">=</span> t.size</span>
<span id="cb9-6"><a href="#cb9-6"></a>        y_n <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> m</span>
<span id="cb9-7"><a href="#cb9-7"></a>        y_n[<span class="dv">0</span>] <span class="op">=</span> y[<span class="dv">0</span>]</span>
<span id="cb9-8"><a href="#cb9-8"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb9-9"><a href="#cb9-9"></a>            <span class="op">&lt;&lt;</span>parareal<span class="op">-</span>core<span class="op">&gt;&gt;</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>        <span class="cf">return</span> y_n</span>
<span id="cb9-11"><a href="#cb9-11"></a>    </span>
<span id="cb9-12"><a href="#cb9-12"></a>    <span class="cf">return</span> f</span></code></pre></div>
<h3 id="noodlify">Noodlify</h3>
<p>The way we implemented the <code>parareal</code> function is not very efficient. It’s Python, there’s a recursion in the dependency, so no way to sweeten it up with <code>numpy</code>. Suppose however, that the <code>fine</code> solution may take a while to compute, and we only use Python to steer the computation. How can we paralellise the implementation of <code>parareal</code>? The answer is: we don’t need to! Noodles can do it for us.</p>
<div class="noweb">
<p>«noodlify»=</p>
</div>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="noodlify-2"><a href="#noodlify-2"></a><span class="im">import</span> noodles</span>
<span id="noodlify-3"><a href="#noodlify-3"></a><span class="im">from</span> noodles.draw_workflow <span class="im">import</span> draw_workflow</span>
<span id="noodlify-4"><a href="#noodlify-4"></a></span>
<span id="noodlify-5"><a href="#noodlify-5"></a><span class="im">from</span> paranoodles.harmonic_oscillator <span class="im">import</span> <span class="op">\</span></span>
<span id="noodlify-6"><a href="#noodlify-6"></a>    ( harmonic_oscillator, underdamped_solution )</span>
<span id="noodlify-7"><a href="#noodlify-7"></a><span class="im">from</span> paranoodles.forward_euler <span class="im">import</span> <span class="op">\</span></span>
<span id="noodlify-8"><a href="#noodlify-8"></a>    ( forward_euler )</span>
<span id="noodlify-9"><a href="#noodlify-9"></a><span class="im">from</span> paranoodles.tabulate_solution <span class="im">import</span> <span class="op">\</span></span>
<span id="noodlify-10"><a href="#noodlify-10"></a>    ( tabulate )</span>
<span id="noodlify-11"><a href="#noodlify-11"></a><span class="im">from</span> paranoodles.parareal <span class="im">import</span> <span class="op">\</span></span>
<span id="noodlify-12"><a href="#noodlify-12"></a>    ( parareal)</span></code></pre></div>
<p>To see what Noodles does, first we’ll noodlify the direct integration routine in <code>tabulate</code>. We take the same harmonic oscillator we had before. For the sake of argument let’s divide the time line in three steps (so four points).</p>
<div class="noweb">
<p>«noodlify»=+</p>
</div>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1"></a>omega_0 <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="noodlify-2"><a href="#noodlify-2"></a>zeta <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="noodlify-3"><a href="#noodlify-3"></a>f <span class="op">=</span> harmonic_oscillator(omega_0, zeta)</span>
<span id="noodlify-4"><a href="#noodlify-4"></a>t <span class="op">=</span> np.linspace(<span class="fl">0.0</span>, <span class="fl">15.0</span>, <span class="dv">4</span>)</span></code></pre></div>
<p>We now define the <code>fine</code> integrator:</p>
<div class="noweb">
<p>«noodlify»=+</p>
</div>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1"></a>h <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="noodlify-2"><a href="#noodlify-2"></a></span>
<span id="noodlify-3"><a href="#noodlify-3"></a><span class="at">@noodles.schedule</span></span>
<span id="noodlify-4"><a href="#noodlify-4"></a><span class="kw">def</span> fine(x, t_0, t_1):</span>
<span id="noodlify-5"><a href="#noodlify-5"></a>    <span class="cf">return</span> iterate_solution(forward_euler(f), h)(x, t_0, t_1)</span></code></pre></div>
<p>It doesn’t really matter what the fine integrator does, since we won’t run anything. We’ll just pretend. The <code>noodles.schedule</code> decorator makes sure that the integrator is never called, we just store the information that we <em>want</em> to call the <code>fine</code> function. The resulting value is a <em>promise</em> that at some point we <em>will</em> call the <code>fine</code> function. The nice thing is, that this promise behaves like any other Python object, it even qualifies as a <code>Vector</code>! The <code>tabulate</code> routine returns a <code>Sequence</code> of <code>Vector</code>s, in this case a list of promises. The <code>noodles.gather</code> function takes a list of promises and turns it into a promise of a list (in fact, its definition boils down to <code>noodles.schedule(list)</code>).</p>
<div class="noweb">
<p>«noodlify»=+</p>
</div>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1"></a>y_euler <span class="op">=</span> noodles.gather(</span>
<span id="noodlify-2"><a href="#noodlify-2"></a>    <span class="op">*</span>tabulate(noodles.schedule(fine), [<span class="fl">1.0</span>, <span class="fl">0.0</span>], t))</span></code></pre></div>
<p>We can draw the resulting workflow:</p>
<div class="noweb">
<p>«noodlify»=+</p>
</div>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1"></a><span class="kw">def</span> paint(node, name):</span>
<span id="noodlify-2"><a href="#noodlify-2"></a>    <span class="cf">if</span> name <span class="op">==</span> <span class="st">&quot;coarse&quot;</span>:</span>
<span id="noodlify-3"><a href="#noodlify-3"></a>        node.attr[<span class="st">&quot;fillcolor&quot;</span>] <span class="op">=</span> <span class="st">&quot;#cccccc&quot;</span></span>
<span id="noodlify-4"><a href="#noodlify-4"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;fine&quot;</span>:</span>
<span id="noodlify-5"><a href="#noodlify-5"></a>        node.attr[<span class="st">&quot;fillcolor&quot;</span>] <span class="op">=</span> <span class="st">&quot;#88ff88&quot;</span></span>
<span id="noodlify-6"><a href="#noodlify-6"></a>    <span class="cf">else</span>:</span>
<span id="noodlify-7"><a href="#noodlify-7"></a>        node.attr[<span class="st">&quot;fillcolor&quot;</span>] <span class="op">=</span> <span class="st">&quot;#ffffff&quot;</span>        </span>
<span id="noodlify-8"><a href="#noodlify-8"></a> </span>
<span id="noodlify-9"><a href="#noodlify-9"></a>draw_workflow(<span class="st">&#39;seq-graph.svg&#39;</span>, noodles.get_workflow(y_euler), paint)</span></code></pre></div>
<figure>
<img src="./seq-graph.svg" style="width:50.0%" alt="" /><figcaption>Sequential integration</figcaption>
</figure>
<p>This workflow is entirely sequential, every step depending on the preceding one. Now for Parareal! We also define the <code>coarse</code> integrator.</p>
<div class="noweb">
<p>«noodlify»=+</p>
</div>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1"></a><span class="at">@noodles.schedule</span></span>
<span id="noodlify-2"><a href="#noodlify-2"></a><span class="kw">def</span> coarse(x, t_0, t_1):</span>
<span id="noodlify-3"><a href="#noodlify-3"></a>    <span class="cf">return</span> forward_euler(f)(x, t_0, t_1)</span></code></pre></div>
<p>Parareal is initialised with the ODE integrated by the coarse integrator, just like we did before with the fine one.</p>
<div class="noweb">
<p>«noodlify»=+</p>
</div>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1"></a>y_first <span class="op">=</span> noodles.gather(<span class="op">*</span>tabulate(noodles.schedule(coarse), [<span class="fl">1.0</span>, <span class="fl">0.0</span>], t))</span></code></pre></div>
<p>We can now perform a single iteration of Parareal to see what the workflow looks like:</p>
<div class="noweb">
<p>«noodlify»=+</p>
</div>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1"></a>y_parareal <span class="op">=</span> noodles.gather(<span class="op">*</span>parareal(coarse, fine)(y_first, t))</span>
<span id="noodlify-2"><a href="#noodlify-2"></a>draw_workflow(<span class="st">&#39;parareal-graph.svg&#39;</span>, noodles.get_workflow(y_parareal), paint)</span></code></pre></div>
<figure>
<img src="./parareal-graph.svg" alt="" /><figcaption>Parareal iteration; the fine integrators (green) can be run in parallel.</figcaption>
</figure>
<h2 id="tests">Tests</h2>
<div class="noweb">
<p>file: «test.py»=</p>
</div>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="op">&lt;&lt;</span>plot<span class="op">-</span>harmonic<span class="op">-</span>oscillator<span class="op">&gt;&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="op">&lt;&lt;</span>noodlify<span class="op">&gt;&gt;</span></span></code></pre></div>
</body>
</html>
