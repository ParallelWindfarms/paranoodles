<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Johan Hidding" />
  <title>ParaNoodles</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!-- Bootstrap 4.5.0 stylesheet -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
  <link rel="stylesheet" href="css/mods.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
  <!-- pandoc-eqnos: equation style -->
  <style>
    .eqnos { display: inline-block; position: relative; width: 100%; }
    .eqnos br { display: none; }
    .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
  </style>
<!-- <script data-main="scripts/main" src="js/require.js"></script> -->
  <!-- Load React. -->
  <!-- Note: when deploying, replace "development.js" with "production.min.js". -->
<!--  <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script> -->


</head>
<body class="d-flex flex-column">

<nav id="TOC" class="navbar navbar-dark bg-dark">
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <a href="#" class="ml-5 mr-auto navbar-brand">ParaNoodles<br><span style="font-size: smaller"> 
        by <i>Johan Hidding</i></span></a>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul>
<li><a href="#installing">Installing</a></li>
<li><a href="#module">Module</a></li>
<li><a href="#problem-statement">Problem statement</a></li>
<li><a href="#parareal">Parareal</a></li>
<li><a href="#create-example-file">Create example file</a></li>
</ul>
</div>
</nav>

<!-- <nav class="navbar navbar-dark navbar-expand-md bg-dark mb-4">
<p class="author">Johan Hidding</p>
</nav>
 -->

<main role="main" class="flex-fill"><div class="container my-5">
<p>ParaNoodles is an implementation of the Parareal on top of the Noodles framework in Python. <strong>Parareal</strong> is an algorithm for Parallel-in-time integration of ODEs (or PDEs through method of lines). <strong>Noodles</strong> is a framework for parallel programming in Python.</p>
<h1 id="installing">Installing</h1>
<h2 id="cloning">Cloning</h2>
<p>To clone this repo including the <code>bootstrap</code> submodule (for rendering the documentation),</p>
<pre><code>git clone --recursive git@github.com:parallelwindfarms/paranoodles</code></pre>
<p>If you forgot to use <code>--recursive</code> and want the submodule after all:</p>
<pre><code>git submodule update --init --recursive</code></pre>
<h2 id="building-paranoodles">Building ParaNoodles</h2>
<p>ParaNoodles is 100% Python.</p>
<pre><code>pip install .</code></pre>
<p>To run on a cluster environment (with the Xenon runner) you need <code>pyxenon</code> installed and a decently recent Java Runtime present.</p>
<pre><code>pip install pyxenon</code></pre>
<h2 id="building-documentation">Building documentation</h2>
<p>This is a literate code. To build the documentation you need <a href="https://pandoc.org">Pandoc ≤ 2.7</a>, and several Pandoc filters installed,</p>
<pre><code>pip install pandoc-eqnos pandoc-fignos entangled-filters</code></pre>
<h1 id="module">Module</h1>
<div class="annotated-code">
<p><span><em>«paranoodles/__init__.py»=</em></span></p>
<div class="sourceCode" id="cb6" data-file="paranoodles/__init__.py"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .tabulate_solution <span class="im">import</span> tabulate</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .parareal <span class="im">import</span> parareal</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> . <span class="im">import</span> abstract</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> noodles <span class="im">import</span> schedule</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> noodles.run.threading.sqlite3 <span class="im">import</span> run_parallel <span class="im">as</span> run</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>__all__ <span class="op">=</span> [<span class="st">&quot;tabulate&quot;</span>, <span class="st">&quot;parareal&quot;</span>, <span class="st">&quot;schedule&quot;</span>, <span class="st">&quot;run&quot;</span>, <span class="st">&quot;abstract&quot;</span>, <span class="st">&quot;schedule&quot;</span>]</span></code></pre></div>
</div>
<h1 id="problem-statement">Problem statement</h1>
<p>I tried to implement the problem statement using abstract base classes (<code>ABC</code> module) and the <code>typing</code> module. However, type annotation in Python is still an immature feature (to say the least, it’s next to useless). The little annotation remaining should be considered documentation.</p>
<div class="annotated-code">
<p><span><em>«paranoodles/abstract.py»=</em></span></p>
<div class="sourceCode" id="cb7" data-file="paranoodles/abstract.py"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> __future__ <span class="im">import</span> annotations  <span class="co"># enable self-reference in type annotations</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> (Callable, Protocol, TypeVar)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> abc <span class="im">import</span> (ABC, abstractmethod)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>abstract<span class="op">-</span>types<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>We have an ODE in the form</p>
<p><span id="eq:ode" class="eqnos"><span class="math display">\[y&#39; = f(y, t).\]</span><span class="eqnos-number">(1)</span></span></p>
<p>Here <span class="math inline">\(y\)</span> can be a scalar value, a vector of values (say a <code>numpy</code> array), or any expression of <em>state</em>. A naive implementation of an ODE integrator would be</p>
<p><span id="eq:euler-method" class="eqnos"><span class="math display">\[y_{n+1} = y_{n} + \Delta t f(y_{n}, t).\]</span><span class="eqnos-number">(2)</span></span></p>
<p>eq. <a href="#eq:euler-method">2</a> is known as the <em>forward Euler method</em>. We can capture the <em>state</em> <span class="math inline">\(y\)</span> in an abstract class we’ll call <code>Vector</code>. We chose this name because we expect this objects to share (some of) the arithmetic properties of mathematical vectors. Namely, we want to be able to add, subtract and scale them. The chunk below states this need of a basic arithmetic in the form of abstract methods.</p>
<div class="annotated-code">
<p><span><em>«abstract-types»=</em></span></p>
<div class="sourceCode" id="abstract-types"><pre class="sourceCode python"><code class="sourceCode python"><span id="abstract-types-1"><a href="#abstract-types-1" aria-hidden="true" tabindex="-1"></a>TVector <span class="op">=</span> TypeVar(<span class="st">&quot;TVector&quot;</span>, bound<span class="op">=</span><span class="st">&quot;Vector&quot;</span>)</span>
<span id="abstract-types-2"><a href="#abstract-types-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="abstract-types-3"><a href="#abstract-types-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Vector(Protocol):</span>
<span id="abstract-types-4"><a href="#abstract-types-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__add__</span>(<span class="va">self</span>: TVector, other: TVector) <span class="op">-&gt;</span> TVector:</span>
<span id="abstract-types-5"><a href="#abstract-types-5" aria-hidden="true" tabindex="-1"></a>        ...</span>
<span id="abstract-types-6"><a href="#abstract-types-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="abstract-types-7"><a href="#abstract-types-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__sub__</span>(<span class="va">self</span>: TVector, other: TVector) <span class="op">-&gt;</span> TVector:</span>
<span id="abstract-types-8"><a href="#abstract-types-8" aria-hidden="true" tabindex="-1"></a>        ...</span>
<span id="abstract-types-9"><a href="#abstract-types-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="abstract-types-10"><a href="#abstract-types-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__mul__</span>(<span class="va">self</span>: TVector, other: <span class="bu">float</span>) <span class="op">-&gt;</span> TVector:</span>
<span id="abstract-types-11"><a href="#abstract-types-11" aria-hidden="true" tabindex="-1"></a>        ...</span>
<span id="abstract-types-12"><a href="#abstract-types-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="abstract-types-13"><a href="#abstract-types-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__rmul__</span>(<span class="va">self</span>: TVector, other: <span class="bu">float</span>) <span class="op">-&gt;</span> TVector:</span>
<span id="abstract-types-14"><a href="#abstract-types-14" aria-hidden="true" tabindex="-1"></a>        ...</span></code></pre></div>
</div>
<p><em>The implementation of the actual methods can be found below in this document.</em></p>
<p>Note that we don’t make a distinction here between a state vector and a vector representing a change in state. This may change in the future.</p>
<p>An ODE is then given as a function taking a <code>Vector</code> (the state <span class="math inline">\(y\)</span>) and a <code>float</code> (the time <span class="math inline">\(t\)</span>) returning a <code>Vector</code> (the derivative <span class="math inline">\(y&#39; = f(y,t)\)</span> evaluated at <span class="math inline">\((y,t)\)</span>). We define the type <code>Problem</code>:</p>
<div class="annotated-code">
<p><span><em>«abstract-types»+</em></span></p>
<div class="sourceCode" id="abstract-types"><pre class="sourceCode python"><code class="sourceCode python"><span id="abstract-types-1"><a href="#abstract-types-1" aria-hidden="true" tabindex="-1"></a>Problem <span class="op">=</span> Callable[[TVector, <span class="bu">float</span>], TVector]</span></code></pre></div>
</div>
<p>In mathematical notation the snippet above means:</p>
<p><span class="math display">\[Problem : (y, t) \longrightarrow f(y, t) = y&#39;\]</span></p>
<p>If we have a <code>Problem</code>, we’re after a <code>Solution</code>: a function that, given an initial <code>Vector</code> (the initial condition <span class="math inline">\(y_0\)</span>), initial time (<span class="math inline">\(t_0\)</span>) and final time (<span class="math inline">\(t\)</span>), gives the resulting <code>Vector</code> (the solution, <span class="math inline">\(y(t)\)</span> for the given initial conditions).</p>
<div class="annotated-code">
<p><span><em>«abstract-types»+</em></span></p>
<div class="sourceCode" id="abstract-types"><pre class="sourceCode python"><code class="sourceCode python"><span id="abstract-types-1"><a href="#abstract-types-1" aria-hidden="true" tabindex="-1"></a>Solution <span class="op">=</span> Callable[[TVector, <span class="bu">float</span>, <span class="bu">float</span>], TVector]</span></code></pre></div>
</div>
<p>Those readers more familiar with classical physics or mathematics may notice that our <code>Problem</code> object corresponds with the function <span class="math inline">\(f\)</span> in (eq. <a href="#eq:ode">1</a>). The <code>Solution</code> object, on the other hand, corresponds with the evolution operator <span class="math inline">\(\phi\)</span> in equation <a href="#eq:solution">3</a>.</p>
<p><span id="eq:solution" class="eqnos"><span class="math display">\[Solution : (y_0, t_0; t) \longrightarrow \phi(y_0, t_0; t) = y(t).\]</span><span class="eqnos-number">(3)</span></span></p>
<p>Intuitively, <span class="math inline">\(\phi\)</span> represents any method that solves (even approximately) our initial value problem.</p>
<p>As a quick example, think of the differential equation <span class="math inline">\(y&#39; = ry\)</span>. This can be solved by analytical integration. The <code>Problem</code> and <code>Solution</code> objects is in this case are:</p>
<p><span class="math display">\[ Problem : (y, t) \longrightarrow r y \]</span> <span class="math display">\[ Solution : (y_0, t_0; t) \longrightarrow y_0 e^{r(t - t_0)} \]</span></p>
<p>The challenge is, of course, to find a way of transforming a <code>Problem</code> into a <code>Solution</code>. This is what integration algorithms do.</p>
<p><span class="math display">\[ Integration \ algorithm : Problem \longrightarrow Solution \]</span></p>
<p>If we look a bit closely at the definitions of <code>Problem</code> and <code>Solution</code> we’ll notice that an integration algorithm is indeed a functional that accepts functions of <span class="math inline">\((y,t)\)</span> as an input and returns functions of <span class="math inline">\((y_0, t_0, t)\)</span> as an output.</p>
<p><span class="math display">\[ Integration \ algorithm : f \longrightarrow \phi \]</span></p>
<p>An example of such an integration algorithm is the forward Euler method (eq. <a href="#eq:euler-method">2</a>), that can be implemented as:</p>
<div class="annotated-code">
<p><span><em>«paranoodles/forward_euler.py»=</em></span></p>
<div class="sourceCode" id="cb8" data-file="paranoodles/forward_euler.py"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Vector, Problem, Solution)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> forward_euler(f: Problem) <span class="op">-&gt;</span> Solution:</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> step(y: Vector, t_0: <span class="bu">float</span>, t_1: <span class="bu">float</span>) <span class="op">-&gt;</span> Vector:</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Stepping function of Euler method.&quot;&quot;&quot;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y <span class="op">+</span> (t_1 <span class="op">-</span> t_0) <span class="op">*</span> f(y, t_0)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> step</span></code></pre></div>
</div>
<p>Any existing solution can be iterated over to provide a solution over a larger time interval. The <code>iterate_solution</code> function runs a given solution with a step-size fixed to <span class="math inline">\(\Delta t = h\)</span>.</p>
<!--$${\rm Iter}[S, h]\Big|_{t_0, y = y}^{t_1} = \begin{cases}-->
<!--y & t_0 = t_1 \\-->
<!--{\rm Iter}[S, h]\big|_{t_0 + h, y = S(y, t_0, t_0 + h)}^{t_1} & {\rm otherwise}-->
<!--\end{cases}.$$-->
<div class="annotated-code">
<p><span><em>«paranoodles/iterate_solution.py»=</em></span></p>
<div class="sourceCode" id="cb9" data-file="paranoodles/iterate_solution.py"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Vector, Solution)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> iterate_solution(step: Solution, h: <span class="bu">float</span>) <span class="op">-&gt;</span> Solution:</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> iter_step(y: Vector, t_0: <span class="bu">float</span>, t_1: <span class="bu">float</span>) <span class="op">-&gt;</span> Vector:</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Stepping function of iterated solution.&quot;&quot;&quot;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> math.ceil((t_1 <span class="op">-</span> t_0) <span class="op">/</span> h)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        steps <span class="op">=</span> np.arange(t_0, t_1, n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t_a, t_b <span class="kw">in</span> <span class="bu">zip</span>(steps[:<span class="op">-</span><span class="dv">1</span>], steps[<span class="dv">1</span>:]):</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> step(y, t_a, t_b)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> iter_step</span></code></pre></div>
</div>
<h2 id="example-damped-harmonic-oscillator">Example: damped harmonic oscillator</h2>
<p>The harmonic oscillator can model the movement of a pendulum or the vibration of a mass on a string.</p>
<p><span class="math display">\[y&#39;&#39; + 2\zeta \omega_0 y&#39; + \omega_0^2 y = 0,\]</span></p>
<p>where <span class="math inline">\(\omega_0 = \sqrt{k/m}\)</span> and <span class="math inline">\(\zeta = c / 2\sqrt{mk}\)</span>, <span class="math inline">\(k\)</span> being the spring constant, <span class="math inline">\(m\)</span> the test mass and <span class="math inline">\(c\)</span> the friction constant.</p>
<p>To solve this second order ODE we need to introduce a second variable to solve for. Say <span class="math inline">\(q = y\)</span> and <span class="math inline">\(p = y&#39;\)</span>.</p>
<p><span id="eq:harmonic-oscillator" class="eqnos"><span class="math display">\[\begin{aligned}
    q&#39; &amp;= p\\
    p&#39; &amp;= -2\zeta \omega_0 p + \omega_0^2 q
\end{aligned}\]</span><span class="eqnos-number">(4)</span></span> </p>
<p>The <code>Problem</code> is then given as</p>
<div class="annotated-code">
<p><span><em>«paranoodles/harmonic_oscillator.py»=</em></span></p>
<div class="sourceCode" id="cb10" data-file="paranoodles/harmonic_oscillator.py"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Problem)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> harmonic_oscillator(omega_0: <span class="bu">float</span>, zeta: <span class="bu">float</span>) <span class="op">-&gt;</span> Problem:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> f(y, t):</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.r_[y[<span class="dv">1</span>], <span class="op">-</span><span class="dv">2</span> <span class="op">*</span> zeta <span class="op">*</span> omega_0 <span class="op">*</span> y[<span class="dv">1</span>] <span class="op">-</span> omega_0<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> y[<span class="dv">0</span>]]</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>harmonic<span class="op">-</span>oscillator<span class="op">-</span>solution<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<h3 id="exact-solution">Exact solution</h3>
<p>The damped harmonic oscillator has an exact solution, given the ansatz <span class="math inline">\(y = A \exp(z t)\)</span>, we get</p>
<p><span class="math display">\[z_{\pm} = \omega_0\left(-\zeta \pm \sqrt{\zeta^2 - 1}\right).\]</span></p>
<p>and thus the general solution:</p>
<p><span class="math display">\[y(t) = A \exp(z_+ t) + B \exp(z_- t) \ : \zeta \neq 1 \]</span> <span class="math display">\[y(t) = (A + Bt) \exp(-\omega_0 t) : \zeta = 1 \]</span></p>
<p>This dynamical system has three qualitatively different solutions, each of them depending on the sign of the contents of the square root. Particularly, if the contents of the square root are negative, the two possible values for <span class="math inline">\(z\)</span> will be complex numbers, making oscillations possible. More specifically, the three cases are:</p>
<ul>
<li><em>overdamped</em> (<span class="math inline">\(\zeta &gt; 1\)</span> and, thus, both <span class="math inline">\(z\)</span> are real numbers)</li>
<li><em>critical dampening</em> (<span class="math inline">\(\zeta = 1\)</span> and <span class="math inline">\(z\)</span> is real and equal to <span class="math inline">\(-\omega_0\)</span>)</li>
<li><em>underdamped</em> (<span class="math inline">\(\mid \zeta \mid &lt; 1\)</span>, and <span class="math inline">\(z = -\omega_0\zeta \mp i \omega_0 \sqrt{1 - \zeta^2}\)</span>).</li>
</ul>
<p>The underdamped case is typically the most interesting one. In this case we have solutions of the form:</p>
<p><span class="math display">\[y = A\quad \underbrace{\exp(-\omega_0\zeta t)}_{\rm dampening}\quad\underbrace{\exp(\pm i \omega_0 \sqrt{1 - \zeta^2} t)}_{\rm oscillation},\]</span></p>
<p>Given an initial condition <span class="math inline">\(q_0 = 1, p_0 = 0\)</span>, the solution is computed as</p>
<div class="annotated-code">
<p><span><em>«harmonic-oscillator-solution»=</em></span></p>
<div class="sourceCode" id="harmonic-oscillator-solution"><pre class="sourceCode python"><code class="sourceCode python"><span id="harmonic-oscillator-solution-1"><a href="#harmonic-oscillator-solution-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> underdamped_solution(omega_0: <span class="bu">float</span>, zeta: <span class="bu">float</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="harmonic-oscillator-solution-2"><a href="#harmonic-oscillator-solution-2" aria-hidden="true" tabindex="-1"></a>    amp   <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> zeta<span class="op">**</span><span class="dv">2</span>)</span>
<span id="harmonic-oscillator-solution-3"><a href="#harmonic-oscillator-solution-3" aria-hidden="true" tabindex="-1"></a>    phase <span class="op">=</span> np.arcsin(zeta)</span>
<span id="harmonic-oscillator-solution-4"><a href="#harmonic-oscillator-solution-4" aria-hidden="true" tabindex="-1"></a>    freq  <span class="op">=</span> omega_0 <span class="op">*</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> zeta<span class="op">**</span><span class="dv">2</span>)</span>
<span id="harmonic-oscillator-solution-5"><a href="#harmonic-oscillator-solution-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="harmonic-oscillator-solution-6"><a href="#harmonic-oscillator-solution-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> f(t):</span>
<span id="harmonic-oscillator-solution-7"><a href="#harmonic-oscillator-solution-7" aria-hidden="true" tabindex="-1"></a>        dampening <span class="op">=</span> np.exp(<span class="op">-</span>omega_0<span class="op">*</span>zeta<span class="op">*</span>t)</span>
<span id="harmonic-oscillator-solution-8"><a href="#harmonic-oscillator-solution-8" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> amp <span class="op">*</span> dampening <span class="op">*</span> np.cos(freq <span class="op">*</span> t <span class="op">-</span> phase)</span>
<span id="harmonic-oscillator-solution-9"><a href="#harmonic-oscillator-solution-9" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="op">-</span> amp <span class="op">*</span> omega_0 <span class="op">*</span> dampening <span class="op">*</span> np.sin(freq <span class="op">*</span> t)</span>
<span id="harmonic-oscillator-solution-10"><a href="#harmonic-oscillator-solution-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.c_[q, p]</span>
<span id="harmonic-oscillator-solution-11"><a href="#harmonic-oscillator-solution-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f</span></code></pre></div>
</div>
<h3 id="numeric-solution">Numeric solution</h3>
<p>To plot a <code>Solution</code>, we need to tabulate the results for a given sequence of time points.</p>
<div class="annotated-code">
<p><span><em>«paranoodles/tabulate_solution.py»=</em></span></p>
<div class="sourceCode" id="cb11" data-file="paranoodles/tabulate_solution.py"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Solution, Vector)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> (Sequence, Any)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>Array <span class="op">=</span> Any</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tabulate(step: Solution, y_0: Vector, t: Array) <span class="op">-&gt;</span> Sequence[Vector]:</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Tabulate the step-wise solution, starting from `y_0`, for every time</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">    point given in array `t`.&quot;&quot;&quot;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(y_0, np.ndarray):</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tabulate_np(step, y_0, t)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> [y_0]</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, t.size):</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        y_i <span class="op">=</span> step(y[i<span class="op">-</span><span class="dv">1</span>], t[i<span class="op">-</span><span class="dv">1</span>], t[i])</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        y.append(y_i)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>tabulate<span class="op">-</span>np<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>In the case that the <code>Vector</code> type is actually a numpy array, we can specialize the <code>tabulate</code> routine to return a larger array.</p>
<div class="annotated-code">
<p><span><em>«tabulate-np»=</em></span></p>
<div class="sourceCode" id="tabulate-np"><pre class="sourceCode python"><code class="sourceCode python"><span id="tabulate-np-1"><a href="#tabulate-np-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tabulate_np(step: Solution, y_0: Array, t: Array) <span class="op">-&gt;</span> Array:</span>
<span id="tabulate-np-2"><a href="#tabulate-np-2" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.zeros(dtype<span class="op">=</span>y_0.dtype, shape<span class="op">=</span>(t.size,) <span class="op">+</span> y_0.shape)</span>
<span id="tabulate-np-3"><a href="#tabulate-np-3" aria-hidden="true" tabindex="-1"></a>    y[<span class="dv">0</span>] <span class="op">=</span> y_0</span>
<span id="tabulate-np-4"><a href="#tabulate-np-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, t.size):</span>
<span id="tabulate-np-5"><a href="#tabulate-np-5" aria-hidden="true" tabindex="-1"></a>        y[i] <span class="op">=</span> step(y[i<span class="op">-</span><span class="dv">1</span>], t[i<span class="op">-</span><span class="dv">1</span>], t[i])</span>
<span id="tabulate-np-6"><a href="#tabulate-np-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span></code></pre></div>
</div>
<h3 id="plotting-the-harmonic-oscillator">Plotting the harmonic oscillator</h3>
<div class="annotated-code">
<p><span><em>«plot-harmonic-oscillator»=</em></span></p>
<div class="sourceCode" id="plot-harmonic-oscillator"><pre class="sourceCode python"><code class="sourceCode python"><span id="plot-harmonic-oscillator-1"><a href="#plot-harmonic-oscillator-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pylab <span class="im">as</span> plt</span>
<span id="plot-harmonic-oscillator-2"><a href="#plot-harmonic-oscillator-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="plot-harmonic-oscillator-3"><a href="#plot-harmonic-oscillator-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="plot-harmonic-oscillator-4"><a href="#plot-harmonic-oscillator-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> paranoodles.harmonic_oscillator <span class="im">import</span> <span class="op">\</span></span>
<span id="plot-harmonic-oscillator-5"><a href="#plot-harmonic-oscillator-5" aria-hidden="true" tabindex="-1"></a>    ( harmonic_oscillator, underdamped_solution )</span>
<span id="plot-harmonic-oscillator-6"><a href="#plot-harmonic-oscillator-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> paranoodles.forward_euler <span class="im">import</span> <span class="op">\</span></span>
<span id="plot-harmonic-oscillator-7"><a href="#plot-harmonic-oscillator-7" aria-hidden="true" tabindex="-1"></a>    ( forward_euler )</span>
<span id="plot-harmonic-oscillator-8"><a href="#plot-harmonic-oscillator-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> paranoodles.tabulate_solution <span class="im">import</span> <span class="op">\</span></span>
<span id="plot-harmonic-oscillator-9"><a href="#plot-harmonic-oscillator-9" aria-hidden="true" tabindex="-1"></a>    ( tabulate )</span>
<span id="plot-harmonic-oscillator-10"><a href="#plot-harmonic-oscillator-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="plot-harmonic-oscillator-11"><a href="#plot-harmonic-oscillator-11" aria-hidden="true" tabindex="-1"></a>omega_0 <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="plot-harmonic-oscillator-12"><a href="#plot-harmonic-oscillator-12" aria-hidden="true" tabindex="-1"></a>zeta <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="plot-harmonic-oscillator-13"><a href="#plot-harmonic-oscillator-13" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> harmonic_oscillator(omega_0, zeta)</span>
<span id="plot-harmonic-oscillator-14"><a href="#plot-harmonic-oscillator-14" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="fl">0.0</span>, <span class="fl">15.0</span>, <span class="dv">100</span>)</span>
<span id="plot-harmonic-oscillator-15"><a href="#plot-harmonic-oscillator-15" aria-hidden="true" tabindex="-1"></a>y_euler <span class="op">=</span> tabulate(forward_euler(f), np.r_[<span class="fl">1.0</span>, <span class="fl">0.0</span>], t)</span>
<span id="plot-harmonic-oscillator-16"><a href="#plot-harmonic-oscillator-16" aria-hidden="true" tabindex="-1"></a>y_exact <span class="op">=</span> underdamped_solution(omega_0, zeta)(t)</span>
<span id="plot-harmonic-oscillator-17"><a href="#plot-harmonic-oscillator-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="plot-harmonic-oscillator-18"><a href="#plot-harmonic-oscillator-18" aria-hidden="true" tabindex="-1"></a>plt.plot(t, y_euler[:,<span class="dv">0</span>], color<span class="op">=</span><span class="st">&#39;slateblue&#39;</span>, label<span class="op">=</span><span class="st">&quot;euler&quot;</span>)</span>
<span id="plot-harmonic-oscillator-19"><a href="#plot-harmonic-oscillator-19" aria-hidden="true" tabindex="-1"></a>plt.plot(t, y_exact[:,<span class="dv">0</span>], color<span class="op">=</span><span class="st">&#39;k&#39;</span>, label<span class="op">=</span><span class="st">&quot;exact&quot;</span>)</span>
<span id="plot-harmonic-oscillator-20"><a href="#plot-harmonic-oscillator-20" aria-hidden="true" tabindex="-1"></a>plt.plot(t, y_euler[:,<span class="dv">1</span>], color<span class="op">=</span><span class="st">&#39;slateblue&#39;</span>, linestyle<span class="op">=</span><span class="st">&#39;:&#39;</span>)</span>
<span id="plot-harmonic-oscillator-21"><a href="#plot-harmonic-oscillator-21" aria-hidden="true" tabindex="-1"></a>plt.plot(t, y_exact[:,<span class="dv">1</span>], color<span class="op">=</span><span class="st">&#39;k&#39;</span>, linestyle<span class="op">=</span><span class="st">&#39;:&#39;</span>)</span>
<span id="plot-harmonic-oscillator-22"><a href="#plot-harmonic-oscillator-22" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="plot-harmonic-oscillator-23"><a href="#plot-harmonic-oscillator-23" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">&quot;harmonic.svg&quot;</span>)</span></code></pre></div>
</div>
<figure>
<img src="./img/harmonic.svg" alt="Damped harmonic oscillator" /><figcaption aria-hidden="true">Damped harmonic oscillator</figcaption>
</figure>
<h1 id="parareal">Parareal</h1>
<p>From Wikipedia:</p>
<blockquote>
<p>Parareal solves an initial value problem of the form</p>
<p><span class="math display">\[\dot{y}(t) = f(y(t), t), \quad y(t_0) = y_0 \quad \text{with} \quad t_0 \leq t \leq T.\]</span></p>
<p>Here, the right hand side <span class="math inline">\(f\)</span> can correspond to the spatial discretization of a partial differential equation in a method of lines approach. Parareal now requires a decomposition of the time interval <span class="math inline">\([t_0, T]\)</span> into <span class="math inline">\(P\)</span> so-called time slices <span class="math inline">\([t_j, t_{j+1}]\)</span> such that</p>
<p><span class="math display">\[[t_0, T] = [t_0, t_1] \cup [t_1, t_2] \cup \ldots \cup [t_{P-1}, t_{P} ].\]</span></p>
<p>Each time slice is assigned to one processing unit when parallelizing the algorithm, so that <span class="math inline">\(P\)</span> is equal to the number of processing units used for Parareal.</p>
<p>Parareal is based on the iterative application of two methods for integration of ordinary differential equations. One, commonly labelled <span class="math inline">\({\mathcal {F}}\)</span>, should be of high accuracy and computational cost while the other, typically labelled <span class="math inline">\({\mathcal {G}}\)</span>, must be computationally cheap but can be much less accurate. Typically, some form of Runge-Kutta method is chosen for both coarse and fine integrator, where <span class="math inline">\({\mathcal {G}}\)</span> might be of lower order and use a larger time step than <span class="math inline">\({\mathcal {F}}\)</span>. If the initial value problem stems from the discretization of a PDE, <span class="math inline">\({\mathcal {G}}\)</span> can also use a coarser spatial discretization, but this can negatively impact convergence unless high order interpolation is used. The result of numerical integration with one of these methods over a time slice <span class="math inline">\([t_{j}, t_{j+1}]\)</span> for some starting value <span class="math inline">\(y_{j}\)</span> given at <span class="math inline">\(t_{j}\)</span> is then written as</p>
<p><span class="math display">\[y = \mathcal{F}(y_j, t_j, t_{j+1})\ {\rm or}\ y = \mathcal{G}(y_j, t_j, t_{j+1}).\]</span></p>
<p>Serial time integration with the fine method would then correspond to a step-by-step computation of</p>
<p><span class="math display">\[y_{j+1} = \mathcal{F}(y_j, t_j, t_{j+1}), \quad j=0, \ldots, P-1.\]</span></p>
<p>Parareal instead uses the following iteration</p>
<p><span class="math display">\[y_{j+1}^{k+1} = \mathcal{G}(y^{k+1}_j, t_j, t_{j+1}) + \mathcal{F}(y^k_j, t_j, t_{j+1}) - \mathcal{G}(y^k_j, t_j, t_{j+1}),\\ \quad j=0, \ldots, P-1, \quad k=0, \ldots, K-1,\]</span></p>
<p>where <span class="math inline">\(k\)</span> is the iteration counter. As the iteration converges and <span class="math inline">\(y^{k+1}_j - y^k_j \to 0\)</span>, the terms from the coarse method cancel out and Parareal reproduces the solution that is obtained by the serial execution of the fine method only. It can be shown that Parareal converges after a maximum of <span class="math inline">\(P\)</span> iterations. For Parareal to provide speedup, however, it has to converge in a number of iterations significantly smaller than the number of time slices, that is <span class="math inline">\(K \ll P\)</span>.</p>
<p>In the Parareal iteration, the computationally expensive evaluation of <span class="math inline">\(\mathcal{F}(y^k_j, t_j, t_{j+1})\)</span> can be performed in parallel on <span class="math inline">\(P\)</span> processing units. By contrast, the dependency of <span class="math inline">\(y^{k+1}_{j+1}\)</span> on <span class="math inline">\(\mathcal{G}(y^{k+1}_j, t_j, t_{j+1})\)</span> means that the coarse correction has to be computed in serial order.</p>
</blockquote>
<p>Don’t get blinded by the details of the algorithm. After all, everything boils down to an update equation that uses a state vector <span class="math inline">\(y\)</span> to calculate the state at the immediately next future step (in the same fashion as equation eq. <a href="#eq:euler-method">2</a> did). The core equation translates to:</p>
<div class="annotated-code">
<p><span><em>«parareal-core»=</em></span></p>
<div class="sourceCode" id="parareal-core"><pre class="sourceCode python"><code class="sourceCode python"><span id="parareal-core-1"><a href="#parareal-core-1" aria-hidden="true" tabindex="-1"></a>y_n[i] <span class="op">=</span> coarse(y_n[i<span class="op">-</span><span class="dv">1</span>], t[i<span class="op">-</span><span class="dv">1</span>], t[i]) <span class="op">\</span></span>
<span id="parareal-core-2"><a href="#parareal-core-2" aria-hidden="true" tabindex="-1"></a>       <span class="op">+</span> fine(y[i<span class="op">-</span><span class="dv">1</span>], t[i<span class="op">-</span><span class="dv">1</span>], t[i]) <span class="op">\</span></span>
<span id="parareal-core-3"><a href="#parareal-core-3" aria-hidden="true" tabindex="-1"></a>       <span class="op">-</span> coarse(y[i<span class="op">-</span><span class="dv">1</span>], t[i<span class="op">-</span><span class="dv">1</span>], t[i])</span></code></pre></div>
</div>
<p>The rest is boiler plate.</p>
<div class="annotated-code">
<p><span><em>«paranoodles/parareal.py»=</em></span></p>
<div class="sourceCode" id="cb12" data-file="paranoodles/parareal.py"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Solution)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parareal(coarse: Solution, fine: Solution):</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> f(y, t):</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> t.size</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        y_n <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> m</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        y_n[<span class="dv">0</span>] <span class="op">=</span> y[<span class="dv">0</span>]</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;&lt;</span>parareal<span class="op">-</span>core<span class="op">&gt;&gt;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y_n</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f</span></code></pre></div>
</div>
<h2 id="noodlify">Noodlify</h2>
<p>The way we implemented the <code>parareal</code> function is not very efficient. It’s Python, there’s a recursion in the dependency, so no way to sweeten it up with <code>numpy</code>. Suppose however, that the <code>fine</code> solution may take a while to compute, and we only use Python to steer the computation. How can we paralellise the implementation of <code>parareal</code>? The answer is: we don’t need to! Noodles can do it for us.</p>
<div class="annotated-code">
<p><span><em>«import-noodles»=</em></span></p>
<div class="sourceCode" id="import-noodles"><pre class="sourceCode python"><code class="sourceCode python"><span id="import-noodles-1"><a href="#import-noodles-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> noodles</span></code></pre></div>
</div>
<div class="annotated-code">
<p><span><em>«noodlify»=</em></span></p>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="im">import</span><span class="op">-</span>noodles<span class="op">&gt;&gt;</span></span>
<span id="noodlify-2"><a href="#noodlify-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="noodlify-3"><a href="#noodlify-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> noodles.draw_workflow <span class="im">import</span> draw_workflow</span>
<span id="noodlify-4"><a href="#noodlify-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="noodlify-5"><a href="#noodlify-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> paranoodles.harmonic_oscillator <span class="im">import</span> <span class="op">\</span></span>
<span id="noodlify-6"><a href="#noodlify-6" aria-hidden="true" tabindex="-1"></a>    ( harmonic_oscillator, underdamped_solution )</span>
<span id="noodlify-7"><a href="#noodlify-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> paranoodles.forward_euler <span class="im">import</span> <span class="op">\</span></span>
<span id="noodlify-8"><a href="#noodlify-8" aria-hidden="true" tabindex="-1"></a>    ( forward_euler )</span>
<span id="noodlify-9"><a href="#noodlify-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> paranoodles.tabulate_solution <span class="im">import</span> <span class="op">\</span></span>
<span id="noodlify-10"><a href="#noodlify-10" aria-hidden="true" tabindex="-1"></a>    ( tabulate )</span>
<span id="noodlify-11"><a href="#noodlify-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> paranoodles.parareal <span class="im">import</span> <span class="op">\</span></span>
<span id="noodlify-12"><a href="#noodlify-12" aria-hidden="true" tabindex="-1"></a>    ( parareal )</span></code></pre></div>
</div>
<p>To see what Noodles does, first we’ll noodlify the direct integration routine in <code>tabulate</code>. We take the same harmonic oscillator we had before. For the sake of argument let’s divide the time line in three steps (so four points).</p>
<div class="annotated-code">
<p><span><em>«noodlify»+</em></span></p>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1" aria-hidden="true" tabindex="-1"></a>omega_0 <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="noodlify-2"><a href="#noodlify-2" aria-hidden="true" tabindex="-1"></a>zeta <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="noodlify-3"><a href="#noodlify-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> harmonic_oscillator(omega_0, zeta)</span>
<span id="noodlify-4"><a href="#noodlify-4" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="fl">0.0</span>, <span class="fl">15.0</span>, <span class="dv">4</span>)</span></code></pre></div>
</div>
<p>We now define the <code>fine</code> integrator:</p>
<div class="annotated-code">
<p><span><em>«noodlify»+</em></span></p>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="noodlify-2"><a href="#noodlify-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="noodlify-3"><a href="#noodlify-3" aria-hidden="true" tabindex="-1"></a><span class="at">@noodles.schedule</span></span>
<span id="noodlify-4"><a href="#noodlify-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fine(x, t_0, t_1):</span>
<span id="noodlify-5"><a href="#noodlify-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> iterate_solution(forward_euler(f), h)(x, t_0, t_1)</span></code></pre></div>
</div>
<p>It doesn’t really matter what the fine integrator does, since we won’t run anything. We’ll just pretend. The <code>noodles.schedule</code> decorator makes sure that the integrator is never called, we just store the information that we <em>want</em> to call the <code>fine</code> function. The resulting value is a <em>promise</em> that at some point we <em>will</em> call the <code>fine</code> function. The nice thing is, that this promise behaves like any other Python object, it even qualifies as a <code>Vector</code>! The <code>tabulate</code> routine returns a <code>Sequence</code> of <code>Vector</code>s, in this case a list of promises. The <code>noodles.gather</code> function takes a list of promises and turns it into a promise of a list (in fact, its definition boils down to <code>noodles.schedule(list)</code>).</p>
<div class="annotated-code">
<p><span><em>«noodlify»+</em></span></p>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1" aria-hidden="true" tabindex="-1"></a>y_euler <span class="op">=</span> noodles.gather(</span>
<span id="noodlify-2"><a href="#noodlify-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>tabulate(fine, [<span class="fl">1.0</span>, <span class="fl">0.0</span>], t))</span></code></pre></div>
</div>
<p>We can draw the resulting workflow:</p>
<div class="annotated-code">
<p><span><em>«noodlify»+</em></span></p>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> paint(node, name):</span>
<span id="noodlify-2"><a href="#noodlify-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> name <span class="op">==</span> <span class="st">&quot;coarse&quot;</span>:</span>
<span id="noodlify-3"><a href="#noodlify-3" aria-hidden="true" tabindex="-1"></a>        node.attr[<span class="st">&quot;fillcolor&quot;</span>] <span class="op">=</span> <span class="st">&quot;#cccccc&quot;</span></span>
<span id="noodlify-4"><a href="#noodlify-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&quot;fine&quot;</span>:</span>
<span id="noodlify-5"><a href="#noodlify-5" aria-hidden="true" tabindex="-1"></a>        node.attr[<span class="st">&quot;fillcolor&quot;</span>] <span class="op">=</span> <span class="st">&quot;#88ff88&quot;</span></span>
<span id="noodlify-6"><a href="#noodlify-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="noodlify-7"><a href="#noodlify-7" aria-hidden="true" tabindex="-1"></a>        node.attr[<span class="st">&quot;fillcolor&quot;</span>] <span class="op">=</span> <span class="st">&quot;#ffffff&quot;</span></span>
<span id="noodlify-8"><a href="#noodlify-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="noodlify-9"><a href="#noodlify-9" aria-hidden="true" tabindex="-1"></a>draw_workflow(<span class="st">&#39;seq-graph.svg&#39;</span>, noodles.get_workflow(y_euler), paint)</span></code></pre></div>
</div>
<figure>
<img src="./img/seq-graph.svg" style="width:50.0%" alt="Sequential integration" /><figcaption aria-hidden="true">Sequential integration</figcaption>
</figure>
<p>This workflow is entirely sequential, every step depending on the preceding one. Now for Parareal! We also define the <code>coarse</code> integrator.</p>
<div class="annotated-code">
<p><span><em>«noodlify»+</em></span></p>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1" aria-hidden="true" tabindex="-1"></a><span class="at">@noodles.schedule</span></span>
<span id="noodlify-2"><a href="#noodlify-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> coarse(x, t_0, t_1):</span>
<span id="noodlify-3"><a href="#noodlify-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> forward_euler(f)(x, t_0, t_1)</span></code></pre></div>
</div>
<p>Parareal is initialised with the ODE integrated by the coarse integrator, just like we did before with the fine one.</p>
<div class="annotated-code">
<p><span><em>«noodlify»+</em></span></p>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1" aria-hidden="true" tabindex="-1"></a>y_first <span class="op">=</span> noodles.gather(<span class="op">*</span>tabulate(coarse, [<span class="fl">1.0</span>, <span class="fl">0.0</span>], t))</span></code></pre></div>
</div>
<p>We can now perform a single iteration of Parareal to see what the workflow looks like:</p>
<div class="annotated-code">
<p><span><em>«noodlify»+</em></span></p>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1" aria-hidden="true" tabindex="-1"></a>y_parareal <span class="op">=</span> noodles.gather(<span class="op">*</span>parareal(coarse, fine)(y_first, t))</span></code></pre></div>
</div>
<div class="annotated-code">
<p><span><em>«noodlify»+</em></span></p>
<div class="sourceCode" id="noodlify"><pre class="sourceCode python"><code class="sourceCode python"><span id="noodlify-1"><a href="#noodlify-1" aria-hidden="true" tabindex="-1"></a>draw_workflow(<span class="st">&#39;parareal-graph.svg&#39;</span>, noodles.get_workflow(y_parareal), paint)</span></code></pre></div>
</div>
<figure>
<img src="./img/parareal-graph.svg" alt="Parareal iteration; the fine integrators (green) can be run in parallel." /><figcaption aria-hidden="true">Parareal iteration; the fine integrators (green) can be run in parallel.</figcaption>
</figure>
<h1 id="create-example-file">Create example file</h1>
<div class="annotated-code">
<p><span><em>«examples/harmonic_oscillator.py»=</em></span></p>
<div class="sourceCode" id="cb13" data-file="examples/harmonic_oscillator.py"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>plot<span class="op">-</span>harmonic<span class="op">-</span>oscillator<span class="op">&gt;&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>noodlify<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
</div></main>



<!-- Bootstrap 4.5.0 -->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>

<!-- Mathjax -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
